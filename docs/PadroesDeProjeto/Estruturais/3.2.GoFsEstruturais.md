# Módulo: Padrões de Projeto GoFs Estruturais — Decorator


## 1. Introdução ao Decorator (Padrão Estrutural)

O padrão Decorator é um padrão estrutural que permite anexar responsabilidades adicionais a um objeto
em tempo de execução. Decorators fornecem uma alternativa flexível à herança para estender funcionalidades.

No contexto de aplicações web (Django/DRF), decorators são ideais para cross-cutting concerns como
logging, caching, autenticação/validação, ou medição de performance. A implementação deste módulo foca
no `LoggingDecorator` — uma implementação concreta que registra informações sobre requisições HTTP.

---

## 2. Diagrama de Implementação

![alt text](image.png)

Interpretação:
- O diagrama de classes mostra a relação estrutural:
  - `FunctionView` (Component) é o callable original da view.
  - `ViewDecorator` (Decorator) mantém referência a `view_func` e delega a execução.
  - `LoggingDecorator` (ConcreteDecorator) estende `ViewDecorator` e adiciona logging.

- O diagrama de sequência mostra o fluxo runtime:
  - Cliente → Resolvedor de URL → `LoggingDecorator` → View → Banco de dados → View → `LoggingDecorator` → Cliente
  - O `LoggingDecorator` registra entrada, delega à view e registra saída ou erro.


---

## 3. Estratégias Concretas (ConcreteComponent e ConcreteDecorators)

No repositório a modelagem segue as convenções abaixo:

- Component (conceitual): qualquer função ou callable que receba um `request` e retorne uma `HttpResponse`.
  - No projeto, as `ViewSets` do Django REST Framework atuam como ConcreteComponents quando recebem o decorator
    em seus métodos (ex.: `list`, `retrieve`).

- ConcreteComponent (exemplos no projeto):
  - `ForumViewSet.list` — retorna lista de tópicos
  - `ForumViewSet.retrieve` — retorna detalhes de um tópico
  - `ComentarioForumViewSet.create` — cria comentário

- Decorator (base): `ViewDecorator` (arquivo `backend/core/decorators.py`)
  - Mantém `view_func` e chama `view_func(request, *args, **kwargs)`

- ConcreteDecorator (implementado): `LoggingDecorator`
  - Antes de chamar a `view_func`, registra method, path e user
  - Após execução registra status code e tempo de execução
  - Em caso de exceção, registra o erro e re-lança

Exemplo de uso em código (trecho):

```python
from core.decorators import log_request

class ForumViewSet(viewsets.ModelViewSet):
    @log_request
    def list(self, request, *args, **kwargs):
        return super().list(request, *args, **kwargs)
```

---

## 4. Metodologia

Abordagem para a implementação e para a apresentação:

1. **Modelagem**
   - Criar diagramas UML (classe e sequência) que evidenciam a estrutura e o fluxo de execução.
   - Identificar Component, Decorator e ConcreteDecorators.

2. **Implementação**
   - Implementar `ViewDecorator` e `LoggingDecorator` em `backend/core/decorators.py`.
   - Fornecer `log_request` como wrapper para uso via `@log_request`.
   - Escrever testes unitários para cobrir casos: execução, usuário anônimo, métodos HTTP variados, exceções.

3. **Validação**
   - Executar `python manage.py test core.tests_decorators` (8 testes) e garantir que passam.
   - Verificar logs executando o servidor e realizando requisições manuais com o navegador ou curl.

4. **Documentação e Apresentação**
   - Incluir diagramas (PlantUML) no repositório e instruções de geração (Docker/PlantUML/online).
   - Preparar roteiro de apresentação (5 minutos) que contenha:
     - Demonstração do código em execução (executar servidor e acessar endpoints) — mostrar logs no terminal.
     - Mostrar diagrama de classe e diagrama de sequência (PNG ou via PlantUML online).
     - Mostrar quadro de participantes & commits (fazer checkout no Git/GitHub e mostrar `git log --oneline --name-only --author` ou a página do repositório com commits).

---

## 5. Rastro aos membros participantes & Commits (recomendação para o vídeo)

No vídeo de apresentação inclua:
- Captura da página de commits do repositório (GitHub/GitLab) mostrando os autores e mensagens.
- Um slide rápido com a tabela de participantes e responsabilidades (quem implementou o decorator, quem escreveu testes, quem criou documentação e diagramas).

Comandos úteis:

```bash
# Ver histórico resumido com autor e mensagem
git log --pretty=format:"%h %an %s" --reverse

# Ver alterações por autor
git shortlog -sne
```

Sugestão: inclua no repositório um arquivo `TEAM.md` com a lista de participantes e responsabilidades.

---

## 6. Riscos, limitações e extensões futuras

- Atualmente, implementamos apenas `LoggingDecorator`. A arquitetura facilita adicionar:
  - `CacheDecorator` (caching por usuário/URL),
  - `PerformanceDecorator` (adicionar header X-Execution-Time),
  - `AuthorizationDecorator` (checar roles antes de executar).

- Observação: Aplicar decorators em métodos de `ViewSet` é prático; aplicar ao nível da classe exigiria um decorator especializado
  (ou `method_decorator` do Django para aplicar por nome de método).

---

## 7. Referências

- Gamma et al., "Design Patterns: Elements of Reusable Object-Oriented Software"
- PlantUML — https://plantuml.com
- Django docs — https://docs.djangoproject.com

---

## 8. Itens de entrega (checklist)

- [x] Código em `backend/core/decorators.py`
- [x] Testes em `backend/core/tests_decorators.py` (8 testes OK)
---

